---
$title@: razbiraemsya-s-coroutine-v-kotlin--chast-vtoraya
author@: Виктор Жарина
description: Цикл статей, чтобы разобраться с идеей и внутренним устройством coroutine в Kotlin
keywords: kotlin,coroutine,under the hood,c,conway,knuth,tatham
image: /static/images/default.png
slugRu: razbiraemsya-s-coroutine-v-kotlin--chast-vtoraya
$dates:
  published: 2024-04-24 13:18:48
---
<h3>Введение</h3>

Первое упоминание корутин дано в статье 1963 года (<a href="#conway-article">1</a>) и о ней <a href="https://viktor.zharina.info/posts/razbiraemsya-s-coroutine-v-kotlin-chast-pervaya/">первая часть</a>. После прочтения статьи, сказать честно, я не очень понял идею корутин и искал дополнительную информацию. Понадобилось четыре статьи: статья Конвея, глава из книги Дональда Кнута (<a href="#knuth-chapter">2</a>) и две статьи Саймона Тэтхема (<a href="#tatham-article-1">3</a>, <a href="#tatham-article-2">4</a>) и некоторое время, чтобы глубже понять идею. После прочтения статьи Конвея и до прочтения Кнута (ссылка) казалось, что разница между вариантом программа-подпрограмма и две корутины почти косметическая. Казалось, что программы отличаются реализацией. Однако разница более существенная, так как основная идея корутин состоит в том, чтобы отказаться от идеи писать программы, в которых есть подпрограммы, а представлять программу как набор независимых модулей, которые могут обмениваться данными. Д. Кнут предлагает вообще не думать о программе в контексте вызывающий (caler) и вызываемый (callee), а думать о подпрограммах как об отдельных независимых сопрограммах, которые передают друг другу данные при этом умеют сохранять свое состояние перед выходом из сопрограммы и восстанавливать состояние после вызова.

Итак, Конвей работал над компилятором ALGOL и ему приходилось считывать данные с перфокарт и записывать их на магнитную ленту. Насколько я понял, если вначале считать все данные с перфокарты и потом записать считанные данные на ленту, то это отнимет меньше времени, чем если считать часть данных с карты, а потом часть данных записать на ленту. То есть в первом случае делаем один проход считывания и один проход записи, а во втором гораздо больше и число проходов зависит от числа перфокарт. Считывание и запись данных за один проход оказывается выгоднее по времени, чем переключение между считал/записал. Собственно программа, точнее программы, которые он реализовал он назвал корутинами и по своей сути они были двумя независимыми программами, которые передавали управление друг другу.

После прочтения главы из книги Кнута понимаешь, что разница между программ-подпрограмм и сопрограммы не косметическая, а скорее структурная. После некоторых поисков я нашел статьи Саймона Тэтхэма. Собственно статья Конвея, глава из Кнута и статьи Саймона Тэтхема в конечном итоге и стали основной для написания этой статьи. Статья будет введением в корутины, в основном опирающаяся на практику и реализацию корутин на языке Си из статьи Тэтхэма.

Рассмотрим функцию в самой обычной программе. Какие действия можно выполнить над функцией? Можно вызвать функцию, из нее можно вернуться. Вызов функции это приостановка одной функции, создание стекового фрейма и активация другой. Возврат из функции это уничтожение стекового фрейма и возвращение управления/результата обратно. То есть функцию можно приостановить, активировать, завершить и вернуть результат. В классической программе очередной вызов функции это как начало новой жизни. Вызывая функцию вы ничего неизвестно том, что было до ее вызов: нужно инициализировать переменные, выполнить код, вернуть результат. Но, что если придумать некий механизм, который позволяет помнить, что было на предыдущем вызове и начинать не с чистого листа, а из предыдущего состояния. О реализации этой идеи пойдет речь дальше и статья Саймона Тэтхема нам в этом поможет.

<h3>Идея и реализация</h3>

Сразу перейдем к идее сохранить состояние функции и восстановить его при очередном вызове. Нам нужна такая фишка, чтобы каждый раз когда мы вызываем функцию начинать не с чистого листа, а из состояния, которое было на момент предыдущего вызова. Такая функция и есть сопрограмма.

[sourcecode:c]
int function(void) {
    int i;
    for (i = 0; i < 10; i++)
        return i;   /* работать не будет, но это примерно, чего я хочу */
}

function() // 0
function() // 1
…
function() // 9
[/sourcecode]

Как вообще такое можно провернуть? Вот один из примеров.
[sourcecode:c]
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: goto LABEL0;
        case 1: goto LABEL1;
    }
    LABEL0: /* start of function */
    for (i = 0; i < 10; i++) {
        state = 1; /* so we will come back to LABEL1 */
        return i;
        LABEL1:; /* resume control straight after the return */
    }
}
[/sourcecode]

Это с виду странный код с оператором goto позволяет осуществить задуманное. Переменные state и i объявлены как static поэтому сохранят свое значение между вызовами. Первый вызов это инкремент i, state = 1 и return i. Все последующие вызовы goto LABEL1, снова инкремент i, далее state = 1 и return i. Неудобство здесь в том, что для каждого state надо создавать отдельный LABEL. Можно переписать код на что-то подобное

[sourcecode:c]
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: /* стартуем */
        for (i = 0; i < 10; i++) {
            state = 1; /*  при следующем вызове стартуем уже с case1 */
            return i;
            case 1:; /* возвращаем управление сразу после возврата */
        }
    }
}
[/sourcecode]

Этот код эквивалентен предыдущему, только без goto и LABEL и теперь мы можем написать макрос, который спрячет реализацию  и дальше использовать его в коде.

[sourcecode:c]
#define crBegin static int state=0; switch(state) { case 0:
#define crReturn(i,x) do { state=i; return x; case i:; } while (0)
#define crFinish }
int function(void) {
    static int i;
    crBegin;
    for (i = 0; i < 10; i++)
        crReturn(1, i);
    crFinish;
}
[/sourcecode]

В макросе тот же самый недочет, что и в варианте с LABEL, так как нужно добавлять новый label на каждый case. Но это можно исправить с помощью специального макроса __LINE__. Таким образом мы решили и эту проблему.
[sourcecode:c]
#define crReturn(x) do { state=__LINE__; return x; \
                         case __LINE__:; } while (0)
[/sourcecode]
Не вдаваясь в технические детали и отдавая себе отчет в том, что этой реализации недостаточно для полноценной работы корутин мы уже можем написать программу, состоящую из нескольких сопрограмм. Более того можно взять программу и с небольшими изменениями заменить все подпрограммы на сопрограммы. Для этого код каждой подпрограммы нужно обернуть в crBegin, crFinish и return заменить на crReturn.

[sourcecode:c]
function () {
   crBegin()

   while(1) {
      // some code
      if (condition) {
         crReturn(x)
      }
   }

   crFinish()
}
[/sourcecode]
Каждая из этих сопрограмм будет работать независимо и в каждый момент времени находится в определенном состоянии. Особенно хочу отметить, что подпрограмму можно обернуть в некоторую обертку и превратить ее в корутину - программу, которая умеет “засыпать” и “просыпаться”. У корутины нет классического return, она всегда возвращает управление, сохраняя состояние. После прочтения статьи Саймона Тэтхема стало понятнее как устроены корутины под капотом, но не совсем понятно как это использовать и главное в чем преимущества перед другими способами. С этими и другими вопросами я буду разбираться в следующей статье.

Список литературы:

<a id="conway-article">1.</a><a href="https://www.melconway.com/Home/pdf/compiler.pdf">Design of a Separable Transition-diagram Compiler</a>

<a id="knuth-chapter">2.</a><a href="http://www.lib.ysu.am/disciplines_bk/f0f17bee2596e0d913b92ae336317ffa.pdf"> Дональд Кнут - Искусство программирования - Том 1 - Сопрограммы - стр. 229.</a>

<a id="tatham-article-1">3.</a><a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/coroutines-philosophy/">С. Тэтхем - Статья - философия корутин</a>

<a id="tatham-article-2">4.</a><a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">С. Тэтхем - Статья - корутины на языке Си</a>

5.<a href="https://youtu.be/vhf5lU1suL0&t=150">Дмитрий Калугин-Балашов - Видео - Как устроены корутины?</a>

6.<a href="https://www.youtube.com/watch?v=t0AERgx0lrY">Александр Нозик - Видео Мастер-класс - Кое-что о корутинах</a>

<a id="vladimirov-lection">7.</a><a href="https://master.dl.sourceforge.net/project/cpp-lects-rus/cpp-postgraduate/19-coroutines.pdf">Константин Владимиров - Лекция 10 - Корутины</a>

<a id="gor-yt">8.</a><a href="https://www.youtube.com/watch?v=KUhSjfSbINE">Gor Nishanov - Видео - Await 2.0: Stackless Resumable Functions</a>