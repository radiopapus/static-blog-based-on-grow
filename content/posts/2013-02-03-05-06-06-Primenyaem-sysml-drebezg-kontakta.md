---
$title@: Primenyaem-sysml-drebezg-kontakta
author@: Viktor Zharina
$order: 42
$dates:
  published: 2013-02-03 05:06:06
---
<h1>Введение</h1>

В данном посте я применю SysML для описания процесса переключения контакта, у которого возможен дребезг при переключении. На основании данного описания я написал программный код.



На мой взгляд достоинством применения SysML является наглядность и возможность продумать большинство деталей до написания кода. А также возможность изложить и согласовать свой алгоритм или идею с другими участниками проекта.



<h1>Конкретная задача</h1>

Определить положение контакта с учетом дребезга с помощью модуля Beckhoff EL1252 (http://beckhoff.ru/EL1252/). 

<!--more-->

<h1>Возможности и особенности модуля</h1>

Модуль позволяет определить время первого (или последнего) переднего и заднего фронта сигнала. Для примера: исходное положение контакта Off. В течении такта (допустим 2 мс) сигнал изменил свой уровень с On на Off несколько раз. Модуль зарегистрирует время первого (или последнего) перехода в зависимости от того, как он настроен. Далее будем считать, что наш модуль настроен на регистрацию первых фронтов.



<h1>Обозначения</h1>

<table width="100%" border="1" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td valign="top" width="20%">

<p align="center"><strong>Обозначение</strong></p>

</td>

<td valign="top" width="79%">

<p align="center"><strong>Описание</strong></p>

</td>

</tr>

<tr>

<td valign="top" width="20%">a_pos_time_52a</td>

<td valign="top" width="79%">переменная хранит значение временной метки и соответствует входу LatchPos0 модуля EL1252. Обновление значения переменной происходит при регистрации первого переднего фронта сигнала на входе модуля</td>

</tr>

<tr>

<td valign="top" width="20%">a_neg_time_52a</td>

<td valign="top" width="79%">переменная хранит значение временной метки и соответствует входу LatchNeg0 модуля EL1252. Обновление значения переменной происходит при регистрации первого заднего фронта сигнала на входе модуля</td>

</tr>

<tr>

<td valign="top" width="20%">ON_52а</td>

<td valign="top" width="79%">переменная соответствует входу Channel 0 Input модуля EL1252. Хранит текущее значение уровня сигнала (1 - ON, 0 - OFF)</td>

</tr>

<tr>

<td valign="top" width="20%">state_52a</td>

<td valign="top" width="79%">переменная, которая хранит положение контакта 52а, с учетом дребезга (1 - ON, 0 - OFF)</td>

</tr>

<tr>

<td valign="top" width="20%">switch_time</td>

<td valign="top" width="79%">переменная хранит время переключения State_52a</td>

</tr>

<tr>

<td valign="top" width="20%">Nmax</td>

<td valign="top" width="79%">Параметр, характеризующий количество тактов в течении которого положение контакта остается неизменным</td>

</tr>

</tbody>

</table>



<h1>Основная часть</h1>

<h2>Алгоритм определения положения контакта с учетом дребезга</h2>

Определим функциональный блок (рисунок 1), задачей которого будет определение положения контакта с учетом дребезга на основании данных pos_time, neg_time, sig_state. 



<img src="http://viktor.zharina.info/wp-content/uploads/2012/08/fb.jpg" alt="" title="Функциональный блок" width="604" class="aligncenter size-full wp-image-257" />

<p align="center">Рисунок 1</p>



Опишем диаграмму состояний (рисунок 2) и диаграмму деятельности (рисунок 3), согласно которым функциональный блок будет выполнять свою задачу.



<img src="http://viktor.zharina.info/wp-content/uploads/2012/08/diag.jpg" alt="" title="Диаграмма состояний" width="604"  class="aligncenter size-full wp-image-256" />

<p align="center">Рисунок 2</p>



В состояниях «ВКЛ», «ОТКЛ» функциональный блок ожидает выполнения условий для перехода в состояние «ДР». Других действий в данных состояниях функциональный блок не выполняет.



<img src="http://viktor.zharina.info/wp-content/uploads/2012/08/action.jpg" alt="" title="Диаграмма деятельности" width="604" height="693" class="aligncenter size-full wp-image-258" />

<p align="center">Рисунок 3</p>



<h1>Заключение</h1>

Данный документ очень хороший и наглядный помошник для программиста, который хочет разобраться с кодом. 

Аналогичным образом можно проектировать другие функциональные блоки. На основании уже спроектированных блоков можно создавать другие блоки. На основании созданных блоков можно создавать блоки, которые включают другие блоки, тем самым поднимась на уровень выше в абстракциях.