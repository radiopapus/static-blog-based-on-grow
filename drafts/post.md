---
title: Это тестовая запись, опубликованная с помощью Mashinka
lang: ru
description: Это тестовая запись, опубликованная с помощью Mashinka
keywords: запись, mashinka, rust
---

Проект, в котором я участвовал поставлен на паузу, новго пока не предвидится. Я устал и хочу отдохнуть. У меня накопилось более 30 рабочих дней отпуска, но я думаю мне этого не хватит. Как мне кажется прекрасное время заняться образованием и всякой ерундой и хорошенько побездельничать.

Уже прошло более месяца как я изучаю Rust. Чтобы закрепить знания, после прочтения документации, я решил переписать старые скрипты (php) на Rust с некоторыми улучшениями. Эти скрипты я написал довольно давно и они нужны мне для автоматизации публикации записей в блоге. Я не использую wordpress и мой блог это статичный сайт, то есть, грубо говоря, набор html страниц. Мой процесс создания записи выглядит так, что я пишу черновик на локальной машине, далее публикую, потом добавляю данные в индекс для полнотекстового поиска и после этого выгружаю в облачное хранилище. Таким образом мои записи хранятся в репозитории в виде файлов. Никакой б.д., никакого php и никакого backend (формально). Как раз эту запись я публикую с помощью новой CLI утилиты на Rust, которую я назвал Mashinka.

В этой записи я расскажу;
1. Почему я выбрал Rust;
2. Немного о Mashinka
3. Процесс переписывания;
4. Впечатления;
5. Планы и результаты;

## Почему я выбрал Rust

Это все маркетинг и реклама. Просто увидел где-то, прочел, что он быстрый как С++, memory safety и без gc и стало интересно. Это как пошел в магазин со списком товаров, Но увидел какую-то вкусняшку, решил что она должна быть вкусной купил попробовать. Вопрос [почему](https://www.youtube.com/watch?v=vC3jnJy_Ids&t=59s) он очень интересный, но с какого момента очень сложно дать на него ответ. 

## Немного о Mashinka
Это CLI утилита, которая из-за своей специфики не нужна никому, кроме меня. Я решил, что про переписывании буду по-минимому использовать сторонние зависимости. Архитектура такая, что есть набор входных параметров, которые после парсинга превращаются в команды. Каждая команда реализует метод run. На текущий момент реализовано две команды: Publish, Index. Publish переводит запись из состояния черновик в чистовик, а Index добавляет запись в файл, который будет входным файлом для индексатора. Будут еще команды Deploy и Help, может еще что-то понадобится.

## Процесс переписывания

Я решил, что буду заниматься переписыванием на стримах. Возьму старые скрипты на PHP и перепишу. Но перед этим установил Rust и примерно неделю читал
документацию, практиковался и отмечал недочеты, которые обнаружил в русской версии. Я прочитал почти всю документацию, за исключением последней главы и после этого начал вспоминать что я там понаписал в своих скриптах и главное зачем.
Походу работы появлялись ребята, которые заходили на стримы и писали комментарии, иногда бывало так, что комментарии уводили в сторону, иногда мы просто общалисью. Все это увеличивало время переписывания, но это не было тратой времени. Я узнал много разного.

## Впечатления

Я люблю строгие и понятные правила. Первое время я ощущал себя программистом, которого бьют по рукам. То я владение передам, а потом использую переменную, то возвращаю ссылку на переменную, которая вышла за scope. Первое время складывалось впечатление, что я прочел книгу, а на практике собираю все грабли, про которые там писали. Одна штука меня приятно удивила это вывод ошибок компилятора. Читаешь и понимаешь что компилятор пытается общаться с человеком указывая на то, где возникла ошибка и предлагая способ ее исправить. Я бы назвал вывод ошибок компилятора самой крутой, что я видел.
Вообще я считаю, что если концепция имеет высокий порог входа, но при этом дает весомый плюс, то на нее стоит обратить внимание. Memory safety это весомый плюс.
Однако я бы не выбрал Rust для решения задач на LeetCode или в качестве олимпиадного языка, как раз по причине его строгости. При решении задачи хочется выразить идею, а концептуальный слой, как мне кажется, может это усложнить.
Меня не удивил cargo, потому что я считаю, что любой современный язык должен быть подаваться с пакетным менеджером и если его нет, то это проблема.

У меня до сих пор вызывают затруднения модули. Я забываю пометить их public и про то, что нужно создать файл с именем модуля и потом создать дирректорию с таким же именем. Еще помню разбирался с интеграционными тестами и никак не мог понять, как сделать import из основного приложения. Оказалось что надо создать файл lib.rs и там перечислить все модули, которые должны быть доступны в tests.

Мне очень понравилось то, что в Rust нет исключений. С точки зрения CLI я объявил enum Error и использовал thiserror. Там, где возникают проблемы я возвращаю Error и обарбатываю его на самом верхнем уровне. Все ошибки описаны в одном месте. Использование ? делает обработку ошибок довольно изящной.

Да, кстати, enum это не просто перечисление. Приведу пример для наглядности

```rust
/// Список ошибок
#[derive(Error, Debug)]
pub enum Error {
    // config
    #[error("Check parameter format, please. Should be --param-name or --param-name=value")]
    Parse(),
    #[error("Check date time format `{0}`")]
    DateTimeError(ParseError),
    #[error("Value for {0} should be filled (not empty)")]
    EmptyValue(String),
}
```

Таким образом enum может состоять из элементов, где каждый может хранить значение определенного типа и дальше в коде вы можете это использовать. Помимо этого можно написать имплементацию для enum точно также как и для структуры.

Ах да, в rust нет классического привычного наследования. И я поначалу был в ступоре от того, как так жить вообще. Но жить можно и даже посещают некоторые крамольные мысли.

А еще в Rust нет null. Есть Option, который может быть None, но это другое. Вы всегда знаете, где будет этот None, а елси используете match, то компилятор заставит вам обработать этот случай.

Вроде все, что-то вспомню допишу.