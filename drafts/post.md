---
title: Data class vs class для jpa entity 
lang: ru
description: Мои размышления на тему выбора data class против class для jpa entity 
keywords: kotlin, data class, class, jpa entity, spring
---

TLDR;
Подходит data, если id записи генерится на стороне приложения. Избыточно, если id записи генерится на стороне базы данных.

Введение
В разных проектах я видел разное применение. Одни использовали data class, другие просто class. Я решил разобраться и сформировать свое мнение. Начнем с того, что определимся с целью внесения в язык data class.

Целью data class является хранение данных. Они были созданы для удобства сравнения объектов. Напишем data class и посмотрим bytecode. Из bytecode я убрал "лишнее" и оставил только важное для дальнейших рассуждений.

[sourcecode:kotlin]
data class D(val name: String)
[/sourcecode]

[sourcecode:java]
public static final class D {
  @NotNull
  private final String name;

  @NotNull
  public final String getName() {
     return this.name;
  }

  @NotNull
  public String toString() {
     return "D(name=" + this.name + ")";
  }

  public int hashCode() {
     String var10000 = this.name;
     return var10000 != null ? var10000.hashCode() : 0;
  }

  public boolean equals(@Nullable Object var1) {
     if (this != var1) {
        if (var1 instanceof Scratch_7.D) {
           Scratch_7.D var2 = (Scratch_7.D)var1;
           if (Intrinsics.areEqual(this.name, var2.name)) {
              return true;
           }
        }

        return false;
     } else {
        return true;
     }
  }
}
[/sourcecode]
В конечном итоге data класс это синтаксический сахар, который под капотом переопределяет методы toString(), equals(), hashCode(), используя поля переданные в конструктор.

Теперь перейдем к сущностям. Сущности это объекты целью, которых является отображение данных на таблицу в базе данных. На первый взгляд может показаться, что data класс как раз созданы для сущностей, но тут есть несколько моментов. Вообще говоря почти вся канитель сосредоточена вокруг одного поля, которое является первичным ключом в таблице. Обычно это поле носит имя id. Поле id может быть сгенерировано как со стороны приложения, так и со стороны базы данных. Рассмотрим оба эти случая. В первом случае это может быть любое уникальное значение, которое не нарушает правило первичного ключа и однозначно идентифицирует запись. Примером такого типа может быть UUID. Ключевым здесь является то, что id задается на стороне приложения. В этом случае использовать data class для entity оправдано так как объект будет не изменяемым и сравнение двух объектов даст true.

Теперь расcмотрим второй случай когда id генерится на стороне базы, например serial или autoincrement. В этом случае появляется side эффект когда для объекта, созданного в приложении id не задан до момента сохранения в базу данных и для этого же объекта id принимает значение после сохранения в базу данных. Это самый важный момент в рассуждениях. Вот пример.

[sourcecode:kotlin]
val d1 = D(name = "name")
repository.save(d1)
assertTrue(d1 == d1) // но d1 != d1
[/sourcecode]

Чтобы объекты оказались равны нужно переопределять метод equals и использовать в качестве поля для проверки другия поля, которые однозначно идентифицируют запись, вроде ISBN, номера договора и т.д. Дальше hashcode. Если использовать id при построении hashcode, то есть шанс никогда не найти объект в структурах, которые используют значение hashcode в качестве ключа для хранения, hashmap например.

[sourcecode:kotlin]
val d1 = D1(name = "name")
val hs = HashSet<D1>()
hs.add(d1)
repository.save(d1)
hs.contains(d1) // false
[/sourcecode]
С toString все отлично, в каком-то смысле он демонстрирует изменение объекта до и после сохранения. 

Получается, что все три метода нужно переопределять и указание data class для JPA Entity избыточно.

Можно сделать такой вывод: использовать data class для JPA сущности оправдано, если id записи генерируется на стороне приложения и избыточно, если id генерируется на стороне базы данных, так как все равно придется переопределять методы toString, equals и hashcode.